# Graph Schema for CiteWeave Project

This document describes the node and edge (relationship) field specifications for the Neo4j database used in the CiteWeave project.

## Node Types

### Paper
- `id`: Unique identifier for the paper (SHA256 hash, generated by PaperIDGenerator)
- `title`: Paper title (string)
- `authors`: List of author names (list of string)
- `year`: Publication year (int or string)
- `stub`: Boolean indicating if this is a stub paper (only referenced, not uploaded)
- `doi`: Digital Object Identifier (string, optional)
- `journal`: Journal name (string, optional)
- `publisher`: Publisher name (string, optional)
- `volume`: Journal volume (string, optional)
- `issue`: Journal issue (string, optional)
- `pages`: Page range (string, optional)

### Paragraph
- `id`: Unique identifier for the paragraph (e.g., `para_{index}`)
- `text`: Paragraph text content (string)
- `paragraph_index`: Numerical index of the paragraph within the paper (int)
- `section`: Name of the containing section (string) - **Note**: This is a string attribute, not a separate node
- `citation_count`: Number of citations in this paragraph (int)
- `sentence_count`: Number of sentences in this paragraph (int)
- `has_citations`: Boolean indicating if this paragraph contains any citations (bool)
- `word_count`: Total word count of the paragraph (int)
- `char_count`: Total character count of the paragraph (int)
- `page`: PDF page number where this paragraph appears (int, optional)

### Sentence
- `id`: Unique identifier for the sentence (e.g., `{paper_id}_sent_{index}`)
- `text`: Sentence text content (string)
- `sentence_index`: Numerical index of the sentence within the paper (int)
- `has_citations`: Boolean indicating if this sentence contains any citations (bool)
- `word_count`: Word count of the sentence (int)
- `char_count`: Character count of the sentence (int)

### Argument (Legacy Support)
- `id`: Unique identifier for the argument (string)
- `text`: The content of the argument (string)
- `claim_type`: Type of claim (Fact, Value, Policy, etc.)
- `section`: Source section within the document (string, optional)
- `version`: Version identifier for the argument (string)
- `confidence`: Confidence score for the argument (float, optional)
- `custom_tags`: Additional metadata tags (list of string, optional)

### Citation
- `id`: Unique identifier for the citation (string)
- `text`: The cited text or reference (string)
- `source`: Source document (string)
- `metadata`: Additional metadata (JSON or string)

## Relationship Types

### Hierarchical Relationships
- `(:Sentence)-[:BELONGS_TO]->(:Paragraph)` - Sentence belongs to a paragraph
- `(:Sentence)-[:BELONGS_TO]->(:Paper)` - Sentence belongs to a paper
- `(:Paragraph)-[:BELONGS_TO]->(:Paper)` - Paragraph belongs to a paper
- `(:Argument)-[:BELONGS_TO]->(:Paper)` - Argument belongs to a paper (Legacy)

### Citation Relationships
- `(:Sentence)-[:CITES]->(:Paper)`
  - `citation_text`: The actual citation text (string)
  - `citation_context`: Context around the citation (string)
  - `confidence`: Confidence score for the citation (float)
  - `created_at`: Timestamp when the citation was created (datetime)

- `(:Paragraph)-[:CITES]->(:Paper)`
  - `citation_count`: Number of citations to this paper in the paragraph (int)
  - `citation_density`: Density of citations in the paragraph (float)
  - `created_at`: Timestamp when the citation relationship was created (datetime)

### Argument Relationships (Legacy)
- `(:Argument)-[:RELATES]->(:Argument)`
  - `relation_type`: Type of relationship (Supports, Attacks, etc.)
  - `confidence`: Confidence score for the relationship (float, optional)
  - `version`: Version identifier for the relationship (string)

- `(:Argument)-[:RELATES]->(:Paper)`
  - `relation_type`: Type of relationship (Cites, References, etc.)
  - `confidence`: Confidence score for the relationship (float, optional)
  - `version`: Version identifier for the relationship (string)

## Actual Database Structure

### Current Implementation
The actual database structure implemented in the code is:

```
Paper
├── Paragraphs (with section attribute as string)
│   ├── Sentences
│   └── Direct Citations to Papers
└── Arguments (Legacy)
    └── Relations to other Arguments/Papers
```

### Important Notes
- **Section information is stored as a string attribute** in Paragraph nodes, not as separate Section nodes
- **The hierarchy is**: Paper → Paragraph → Sentence
- **Section names** are extracted from PDF structure but stored as metadata, not as graph nodes
- **This design choice** provides flexibility while maintaining performance

## Database Schema Constraints

### Unique Constraints
- `Paper.id` - Paper ID must be unique across the entire database
- `Sentence.id` - Sentence ID must be unique within the paper
- `Paragraph.id` - Paragraph ID must be unique within the paper

### Indexes
- `Paper.id` - Primary index for paper lookups
- `Paper.title` - Index for title-based searches
- `Paper.authors` - Index for author-based searches
- `Paper.year` - Index for year-based filtering
- `Sentence.paper_id` - Index for sentence-paper relationships
- `Paragraph.paper_id` - Index for paragraph-paper relationships
- `Paragraph.section` - Index for section-based filtering (string attribute)

## Query Patterns

### Common Queries
1. **Find all citations to a specific paper**
   ```cypher
   MATCH (s:Sentence)-[:CITES]->(p:Paper {id: $paper_id})
   RETURN s.text, s.sentence_index, p.title
   ```

2. **Get paper structure with paragraphs and sentences**
   ```cypher
   MATCH (p:Paper {id: $paper_id})
   OPTIONAL MATCH (p)<-[:BELONGS_TO]-(para:Paragraph)
   OPTIONAL MATCH (para)<-[:BELONGS_TO]-(s:Sentence)
   RETURN p, para, s
   ORDER BY para.paragraph_index, s.sentence_index
   ```

3. **Find paragraphs by section name**
   ```cypher
   MATCH (para:Paragraph)-[:BELONGS_TO]->(p:Paper {id: $paper_id})
   WHERE para.section = $section_name
   RETURN para.text, para.paragraph_index
   ORDER BY para.paragraph_index
   ```

4. **Find papers with high citation density**
   ```cypher
   MATCH (para:Paragraph)-[:CITES]->(p:Paper)
   WITH p, avg(para.citation_density) as avg_density
   WHERE avg_density > 0.1
   RETURN p.title, avg_density
   ORDER BY avg_density DESC
   ```

## Implementation Details

### Section Handling
```python
# In the actual implementation, sections are handled as follows:
def create_paragraph(self, paragraph_id: str, paper_id: str, text: str,
                    paragraph_index: int, section: str = "",  # section is a string
                    citation_count: int = 0, sentence_count: int = 0,
                    has_citations: bool = False):
    """
    Create paragraph node with section information stored as a string attribute
    """
    query = """
    MERGE (para:Paragraph {id: $paragraph_id})
    SET para.text = $text,
        para.paragraph_index = $paragraph_index,
        para.section = $section,  // Stored as string, not as relationship
        para.citation_count = $citation_count,
        para.sentence_count = $sentence_count,
        para.has_citations = $has_citations
    WITH para
    MATCH (p:Paper {id: $paper_id})
    MERGE (para)-[:BELONGS_TO]->(p)
    """
```

### Data Flow
```
PDF Document → DocumentProcessor → Structure Analysis → Graph Creation
     ↓                    ↓              ↓              ↓
Text Extraction → Section/Paragraph Detection → Paragraph Nodes (with section attribute) → Sentence Nodes
```

## Migration Notes

- The current schema supports both new multi-level citation structure and legacy argument-based structure
- Legacy Argument nodes can coexist with new Sentence/Paragraph nodes
- Citation relationships are available at both sentence and paragraph levels
- Section information is accessible through paragraph queries but not as separate graph nodes
- All new nodes use the unified paper_id system for cross-database consistency

## Performance Considerations

### Advantages of Current Design
- **Simpler Graph Structure**: Fewer nodes and relationships to manage
- **Faster Queries**: Direct access to section information without graph traversal
- **Easier Maintenance**: Section changes don't require graph restructuring
- **Flexible Section Handling**: Section names can be easily updated without affecting graph structure

### Trade-offs
- **Limited Section Analysis**: Cannot perform complex graph operations on sections
- **Section Relationships**: Cannot directly model relationships between sections
- **Section Metadata**: Section-level statistics require aggregation queries

## Future Enhancement Options

### Option 1: Add Section Nodes
If you want to add Section nodes later, you could:
1. Create a migration script to extract section information from paragraphs
2. Create Section nodes and establish BELONGS_TO relationships
3. Update existing queries to use the new structure

### Option 2: Enhanced Section Attributes
Keep the current design but enhance section attributes:
1. Add more section metadata (section_type, section_level, etc.)
2. Create computed properties for section-level statistics
3. Implement section-based indexing for better performance

> **Note:** This schema reflects the actual implementation in the code. The design choice to store section information as paragraph attributes provides a good balance between functionality and performance for most use cases. 