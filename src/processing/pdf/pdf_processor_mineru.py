"""
Enhanced PDF Processor with MinerU Integration
集成MinerU的增强PDF处理器
"""

import os
import re
import json
import logging
import tempfile
import subprocess
from typing import List, Dict, Optional, Tuple
from pathlib import Path
import hashlib

# 继承原有的PDF处理器
from src.processing.pdf.pdf_processor import PDFProcessor

logging.basicConfig(level=logging.INFO)

class MinerUPDFProcessor(PDFProcessor):
    """
    集成MinerU的PDF处理器
    优先使用MinerU进行高质量PDF转Markdown，然后处理Markdown内容
    """
    
    def __init__(self, storage_root: str = "./data/papers/", 
                 mineru_enabled: bool = True, 
                 mineru_fallback: bool = True,
                 preferred_engine: str = "auto"):
        """
        初始化MinerU集成的PDF处理器
        
        Args:
            storage_root: 存储根目录
            mineru_enabled: 是否启用MinerU
            mineru_fallback: MinerU失败时是否回退到传统方法
            preferred_engine: 传统方法的首选引擎
        """
        super().__init__(storage_root, preferred_engine)
        
        self.mineru_enabled = mineru_enabled
        self.mineru_fallback = mineru_fallback
        self.mineru_available = self._check_mineru_availability()
        
        if self.mineru_enabled and not self.mineru_available:
            logging.warning("MinerU is enabled but not available. Will use fallback methods.")
        
        logging.info(f"MinerU PDF Processor initialized. MinerU available: {self.mineru_available}")
    
    def _check_mineru_availability(self) -> bool:
        """检查MinerU是否可用"""
        try:
            result = subprocess.run(['mineru', '--version'], 
                                  capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                logging.info("MinerU is available and ready to use")
                return True
            else:
                logging.warning(f"MinerU version check failed: {result.stderr}")
                return False
        except (subprocess.TimeoutExpired, FileNotFoundError, subprocess.SubprocessError) as e:
            logging.warning(f"MinerU not available: {e}")
            return False
    
    def extract_text_with_best_engine(self, pdf_path: str) -> Tuple[str, Dict]:
        """
        使用最佳引擎提取文本，优先使用MinerU
        
        Args:
            pdf_path: PDF文件路径
            
        Returns:
            Tuple[text, extraction_info]
        """
        if self.mineru_enabled and self.mineru_available:
            try:
                return self._extract_with_mineru(pdf_path)
            except Exception as e:
                logging.warning(f"MinerU extraction failed: {e}")
                if not self.mineru_fallback:
                    raise
                logging.info("Falling back to traditional PDF extraction methods")
        
        # 回退到传统方法
        return super().extract_text_with_best_engine(pdf_path)
    
    def _extract_with_mineru(self, pdf_path: str) -> Tuple[str, Dict]:
        """
        使用MinerU提取PDF内容
        
        Args:
            pdf_path: PDF文件路径
            
        Returns:
            Tuple[extracted_text, extraction_info]
        """
        # 转换为绝对路径
        pdf_path = os.path.abspath(pdf_path)
        
        if not os.path.exists(pdf_path):
            raise RuntimeError(f"PDF file does not exist: {pdf_path}")
        
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_output = os.path.join(temp_dir, "output")
            
            # 构建MinerU命令，使用绝对路径
            cmd = [
                'mineru',
                '-p', pdf_path,
                '-o', temp_output
            ]
            
            logging.info(f"Running MinerU: {' '.join(cmd)}")
            
            # 执行MinerU
            try:
                result = subprocess.run(
                    cmd, 
                    capture_output=True, 
                    text=True, 
                    timeout=300,  # 5分钟超时
                    cwd=os.getcwd()  # 使用当前工作目录而不是临时目录
                )
                
                if result.returncode != 0:
                    raise RuntimeError(f"MinerU failed with return code {result.returncode}: {result.stderr}")
                
                # 查找生成的Markdown文件
                markdown_files = list(Path(temp_output).glob("**/*.md"))
                if not markdown_files:
                    raise RuntimeError("No markdown files generated by MinerU")
                
                # 读取主要的Markdown文件（通常是第一个或最大的）
                main_md_file = max(markdown_files, key=lambda p: p.stat().st_size)
                
                with open(main_md_file, 'r', encoding='utf-8') as f:
                    markdown_content = f.read()
                
                # 尝试读取JSON元数据（如果存在）
                json_files = list(Path(temp_output).glob("**/*.json"))
                metadata = {}
                if json_files:
                    try:
                        with open(json_files[0], 'r', encoding='utf-8') as f:
                            metadata = json.load(f)
                    except Exception as e:
                        logging.debug(f"Could not parse JSON metadata: {e}")
                
                extraction_info = {
                    "engine": "mineru",
                    "quality_score": 10.0,  # MinerU通常质量很高
                    "pages_processed": self._count_pages_from_markdown(markdown_content),
                    "total_pages": self._count_pages_from_markdown(markdown_content),
                    "pages_with_text": self._count_pages_from_markdown(markdown_content),
                    "metadata": metadata,
                    "original_format": "markdown"
                }
                
                logging.info(f"MinerU extraction completed. Generated {len(markdown_content)} characters")
                
                return markdown_content, extraction_info
                
            except subprocess.TimeoutExpired:
                raise RuntimeError("MinerU extraction timed out (5 minutes)")
            except Exception as e:
                raise RuntimeError(f"MinerU extraction error: {e}")
    
    def _count_pages_from_markdown(self, markdown_content: str) -> int:
        """从Markdown内容估算页数"""
        # 简单估算：基于内容长度和常见页面标记
        lines = markdown_content.split('\n')
        
        # 查找页面分隔符或页码标记
        page_markers = 0
        for line in lines:
            if re.search(r'page\s*\d+', line.lower()) or line.strip() in ['---', '***']:
                page_markers += 1
        
        # 如果找到页面标记，使用它们；否则基于内容长度估算
        if page_markers > 0:
            return max(1, page_markers)
        else:
            # 粗略估算：每2000字符约等于1页
            return max(1, len(markdown_content) // 2000)
    
    def extract_document_structure(self, pdf_path: str) -> Dict:
        """
        提取文档结构，优先使用MinerU解析的Markdown
        
        Returns:
            Dict containing:
            - sections: List of sections with their content
            - paragraphs: List of paragraphs with metadata
            - raw_text_blocks: Original text blocks
        """
        if self.mineru_enabled and self.mineru_available:
            try:
                return self._extract_structure_from_mineru(pdf_path)
            except Exception as e:
                logging.warning(f"MinerU structure extraction failed: {e}")
                if not self.mineru_fallback:
                    raise
                logging.info("Falling back to traditional structure extraction")
        
        # 回退到传统方法
        return super().extract_document_structure(pdf_path)
    
    def _extract_structure_from_mineru(self, pdf_path: str) -> Dict:
        """
        从MinerU生成的Markdown中提取文档结构
        """
        markdown_content, extraction_info = self._extract_with_mineru(pdf_path)
        
        # 解析Markdown内容为结构化数据
        sections = self._parse_markdown_sections(markdown_content)
        paragraphs = self._parse_markdown_paragraphs(markdown_content)
        
        return {
            "sections": sections,
            "paragraphs": paragraphs,
            "raw_text_blocks": [{"text": markdown_content, "source": "mineru_markdown"}],
            "extraction_info": extraction_info
        }
    
    def _parse_markdown_sections(self, markdown_content: str) -> List[Dict]:
        """解析Markdown中的章节"""
        sections = []
        lines = markdown_content.split('\n')
        current_section = None
        section_index = 0
        
        for i, line in enumerate(lines):
            line = line.strip()
            
            # 检测标题（# ## ### 等）
            heading_match = re.match(r'^(#{1,6})\s+(.+)$', line)
            if heading_match:
                # 保存上一个章节
                if current_section:
                    sections.append(current_section)
                
                level = len(heading_match.group(1))
                title = heading_match.group(2).strip()
                
                current_section = {
                    "id": f"section_{section_index}",
                    "title": title,
                    "text": "",
                    "index": section_index,
                    "level": level,
                    "section_type": self._classify_section_type(title),
                    "paragraphs": [],
                    "line_start": i
                }
                section_index += 1
            elif current_section and line:
                # 添加内容到当前章节
                current_section["text"] += line + "\n"
        
        # 添加最后一个章节
        if current_section:
            sections.append(current_section)
        
        # 完善章节信息
        for section in sections:
            section["text"] = section["text"].strip()
            section["paragraph_count"] = len(self._extract_paragraphs_from_text(section["text"]))
        
        return sections
    
    def _parse_markdown_paragraphs(self, markdown_content: str) -> List[Dict]:
        """解析Markdown中的段落"""
        paragraphs = []
        
        # 按双换行符分割段落
        raw_paragraphs = re.split(r'\n\s*\n', markdown_content)
        
        paragraph_index = 0
        current_section = "Unknown"
        
        for para_text in raw_paragraphs:
            para_text = para_text.strip()
            if not para_text:
                continue
            
            # 检查是否是标题
            if re.match(r'^#{1,6}\s+', para_text):
                # 更新当前章节
                heading_match = re.match(r'^#{1,6}\s+(.+)$', para_text.split('\n')[0])
                if heading_match:
                    current_section = heading_match.group(1).strip()
                continue
            
            # 创建段落对象
            paragraph = {
                "id": f"para_{paragraph_index}",
                "text": para_text,
                "index": paragraph_index,
                "section": current_section,
                "word_count": len(para_text.split()),
                "char_count": len(para_text),
                "sentence_count": len(self._split_into_sentences(para_text)),
                "citation_count": 0,  # 将在后续步骤中计算
                "has_citations": False
            }
            
            paragraphs.append(paragraph)
            paragraph_index += 1
        
        return paragraphs
    
    def _extract_paragraphs_from_text(self, text: str) -> List[str]:
        """从文本中提取段落"""
        return [p.strip() for p in re.split(r'\n\s*\n', text) if p.strip()]
    
    def _split_into_sentences(self, text: str) -> List[str]:
        """将文本分割为句子"""
        # 简单的句子分割（可以后续使用更复杂的方法）
        sentences = re.split(r'[.!?]+', text)
        return [s.strip() for s in sentences if s.strip()]
    
    def parse_sentences(self, pdf_path: str) -> List[str]:
        """
        解析句子，优先使用MinerU的Markdown输出
        """
        if self.mineru_enabled and self.mineru_available:
            try:
                markdown_content, _ = self._extract_with_mineru(pdf_path)
                
                # 从Markdown中提取句子
                sentences = self._extract_sentences_from_markdown(markdown_content)
                
                logging.info(f"Extracted {len(sentences)} sentences from MinerU markdown")
                return sentences
                
            except Exception as e:
                logging.warning(f"MinerU sentence extraction failed: {e}")
                if not self.mineru_fallback:
                    raise
                logging.info("Falling back to traditional sentence extraction")
        
        # 回退到传统方法
        return super().parse_sentences(pdf_path)
    
    def _extract_sentences_from_markdown(self, markdown_content: str) -> List[str]:
        """
        从Markdown内容中提取句子
        """
        # 清理Markdown标记
        clean_text = self._clean_markdown_text(markdown_content)
        
        # 分离主要内容和引用部分
        main_content, _ = self._separate_main_content_and_references(clean_text)
        
        # 使用改进的学术句子分割
        sentences = self._split_sentences_academic_aware(main_content)
        
        # 过滤和清理句子
        filtered_sentences = self._filter_invalid_sentences(sentences)
        cleaned_sentences = [self._clean_sentence_text(sent) for sent in filtered_sentences]
        
        return [sent for sent in cleaned_sentences if sent.strip()]
    
    def _clean_markdown_text(self, markdown_text: str) -> str:
        """
        清理Markdown文本，移除格式标记但保留内容结构
        """
        text = markdown_text
        
        # 移除代码块
        text = re.sub(r'```.*?```', '', text, flags=re.DOTALL)
        text = re.sub(r'`[^`]+`', '', text)
        
        # 移除标题标记但保留文本
        text = re.sub(r'^#{1,6}\s*', '', text, flags=re.MULTILINE)
        
        # 移除链接但保留文本
        text = re.sub(r'\[([^\]]+)\]\([^)]+\)', r'\1', text)
        
        # 移除粗体和斜体标记
        text = re.sub(r'\*\*([^*]+)\*\*', r'\1', text)
        text = re.sub(r'\*([^*]+)\*', r'\1', text)
        text = re.sub(r'__([^_]+)__', r'\1', text)
        text = re.sub(r'_([^_]+)_', r'\1', text)
        
        # 移除表格标记
        text = re.sub(r'\|[^|\n]*\|', '', text)
        text = re.sub(r'^[-|: ]+$', '', text, flags=re.MULTILINE)
        
        # 清理多余的空白
        text = re.sub(r'\n\s*\n', '\n\n', text)
        text = re.sub(r'[ \t]+', ' ', text)
        
        return text.strip()
    
    def diagnose_pdf_quality(self, pdf_path: str) -> Dict:
        """
        诊断PDF质量，包括MinerU处理能力
        """
        diagnosis = super().diagnose_pdf_quality(pdf_path)
        
        # 添加MinerU可用性信息
        diagnosis["mineru_available"] = self.mineru_available
        diagnosis["mineru_enabled"] = self.mineru_enabled
        
        if self.mineru_available:
            diagnosis["recommended_engine"] = "mineru"
            diagnosis["best_quality_score"] = 10.0
        
        return diagnosis

# 便利函数：创建MinerU集成的PDF处理器实例
def create_mineru_pdf_processor(storage_root: str = "./data/papers/", 
                               mineru_enabled: bool = True) -> MinerUPDFProcessor:
    """
    创建集成MinerU的PDF处理器实例
    
    Args:
        storage_root: 存储根目录
        mineru_enabled: 是否启用MinerU
        
    Returns:
        MinerUPDFProcessor实例
    """
    return MinerUPDFProcessor(storage_root=storage_root, mineru_enabled=mineru_enabled) 