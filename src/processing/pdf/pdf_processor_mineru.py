"""
Enhanced PDF Processor with MinerU Integration
"""

import os
import re
import json
import logging
import tempfile
import subprocess
from typing import List, Dict, Optional, Tuple
from pathlib import Path
import hashlib

# 继承原有的PDF处理器
from src.processing.pdf.pdf_processor import PDFProcessor

logging.basicConfig(level=logging.INFO)

class MinerUPDFProcessor(PDFProcessor):
    """
    PDF processor with MinerU integration.
    Prioritizes using MinerU for high-quality PDF to Markdown conversion, then processes the Markdown content.
    """
    
    def __init__(self, storage_root: str = "./data/papers/", 
                 mineru_enabled: bool = True, 
                 mineru_fallback: bool = True,
                 preferred_engine: str = "auto"):
        """
        Initialize the MinerU-integrated PDF processor.
        
        Args:
            storage_root: Storage root directory
            mineru_enabled: Whether to enable MinerU
            mineru_fallback: Whether to fall back to traditional methods if MinerU fails
            preferred_engine: Preferred engine for traditional methods
        """
        super().__init__(storage_root, preferred_engine)
        
        self.mineru_enabled = mineru_enabled
        self.mineru_fallback = mineru_fallback
        self.mineru_available = self._check_mineru_availability()
        
        if self.mineru_enabled and not self.mineru_available:
            logging.warning("MinerU is enabled but not available. Will use fallback methods.")
        
        logging.info(f"MinerU PDF Processor initialized. MinerU available: {self.mineru_available}")
    
    def _check_mineru_availability(self) -> bool:
        """
        Check if MinerU is available.
        """
        try:
            result = subprocess.run(['mineru', '--version'], 
                                  capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                logging.info("MinerU is available and ready to use")
                return True
            else:
                logging.warning(f"MinerU version check failed: {result.stderr}")
                return False
        except (subprocess.TimeoutExpired, FileNotFoundError, subprocess.SubprocessError) as e:
            logging.warning(f"MinerU not available: {e}")
            return False
    
    def extract_text_with_best_engine(self, pdf_path: str) -> Tuple[str, Dict]:
        """
        Extract text using the best available engine, prioritizing MinerU.
        
        Args:
            pdf_path: PDF file path
            
        Returns:
            Tuple[text, extraction_info]
        """
        if self.mineru_enabled and self.mineru_available:
            try:
                return self._extract_with_mineru(pdf_path)
            except Exception as e:
                logging.warning(f"MinerU extraction failed: {e}")
                if not self.mineru_fallback:
                    raise
                logging.info("Falling back to traditional PDF extraction methods")
        
        # Fallback to traditional methods
        return super().extract_text_with_best_engine(pdf_path)
    
    def _extract_with_mineru(self, pdf_path: str) -> Tuple[str, Dict]:
        """
        Extract PDF content using MinerU.
        
        Args:
            pdf_path: PDF file path
            
        Returns:
            Tuple[extracted_text, extraction_info]
        """
        # Convert to absolute path
        pdf_path = os.path.abspath(pdf_path)
        
        if not os.path.exists(pdf_path):
            raise RuntimeError(f"PDF file does not exist: {pdf_path}")
        
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_output = os.path.join(temp_dir, "output")
            
            # 构建MinerU命令，使用绝对路径
            cmd = [
                'mineru',
                '-p', pdf_path,
                '-o', temp_output
            ]
            
            logging.info(f"Running MinerU: {' '.join(cmd)}")
            
            # 执行MinerU
            try:
                result = subprocess.run(
                    cmd, 
                    capture_output=True, 
                    text=True, 
                    timeout=300,  # 5分钟超时
                    cwd=os.getcwd()  # 使用当前工作目录而不是临时目录
                )
                
                if result.returncode != 0:
                    raise RuntimeError(f"MinerU failed with return code {result.returncode}: {result.stderr}")
                
                # 查找生成的Markdown文件
                markdown_files = list(Path(temp_output).glob("**/*.md"))
                if not markdown_files:
                    raise RuntimeError("No markdown files generated by MinerU")
                
                # 读取主要的Markdown文件（通常是第一个或最大的）
                main_md_file = max(markdown_files, key=lambda p: p.stat().st_size)
                
                with open(main_md_file, 'r', encoding='utf-8') as f:
                    markdown_content = f.read()
                
                # 尝试读取JSON元数据（如果存在）
                json_files = list(Path(temp_output).glob("**/*.json"))
                metadata = {}
                if json_files:
                    try:
                        with open(json_files[0], 'r', encoding='utf-8') as f:
                            metadata = json.load(f)
                    except Exception as e:
                        logging.debug(f"Could not parse JSON metadata: {e}")
                
                extraction_info = {
                    "engine": "mineru",
                    "quality_score": 10.0,  # MinerU通常质量很高
                    "pages_processed": self._count_pages_from_markdown(markdown_content),
                    "total_pages": self._count_pages_from_markdown(markdown_content),
                    "pages_with_text": self._count_pages_from_markdown(markdown_content),
                    "metadata": metadata,
                    "original_format": "markdown"
                }
                
                logging.info(f"MinerU extraction completed. Generated {len(markdown_content)} characters")
                
                return markdown_content, extraction_info
                
            except subprocess.TimeoutExpired:
                raise RuntimeError("MinerU extraction timed out (5 minutes)")
            except Exception as e:
                raise RuntimeError(f"MinerU extraction error: {e}")
    
    def _count_pages_from_markdown(self, markdown_content: str) -> int:
        """Estimate pages from Markdown content."""
        # Simple estimation: based on content length and common page markers
        lines = markdown_content.split('\n')
        
        # Find page separators or page number markers
        page_markers = 0
        for line in lines:
            if re.search(r'page\s*\d+', line.lower()) or line.strip() in ['---', '***']:
                page_markers += 1
        
        # If page markers are found, use them; otherwise estimate based on content length
        if page_markers > 0:
            return max(1, page_markers)
        else:
            # Rough estimation: approximately 1 page per 2000 characters
            return max(1, len(markdown_content) // 2000)
    
    def extract_document_structure(self, pdf_path: str) -> Dict:
        """
        Extract document structure, prioritizing MinerU's parsed Markdown.
        
        Returns:
            Dict containing:
            - sections: List of sections with their content
            - paragraphs: List of paragraphs with metadata
            - raw_text_blocks: Original text blocks
        """
        if self.mineru_enabled and self.mineru_available:
            try:
                return self._extract_structure_from_mineru(pdf_path)
            except Exception as e:
                logging.warning(f"MinerU structure extraction failed: {e}")
                if not self.mineru_fallback:
                    raise
                logging.info("Falling back to traditional structure extraction")
        
        # Fallback to traditional methods
        return super().extract_document_structure(pdf_path)
    
    def _extract_structure_from_mineru(self, pdf_path: str) -> Dict:
        """
        Extract document structure from MinerU's generated Markdown.
        """
        markdown_content, extraction_info = self._extract_with_mineru(pdf_path)
        
        # Parse Markdown content into structured data
        sections = self._parse_markdown_sections(markdown_content)
        paragraphs = self._parse_markdown_paragraphs(markdown_content)
        
        return {
            "sections": sections,
            "paragraphs": paragraphs,
            "raw_text_blocks": [{"text": markdown_content, "source": "mineru_markdown"}],
            "extraction_info": extraction_info
        }
    
    def _parse_markdown_sections(self, markdown_content: str) -> List[Dict]:
        """Parse Markdown sections."""
        sections = []
        lines = markdown_content.split('\n')
        current_section = None
        section_index = 0
        
        for i, line in enumerate(lines):
            line = line.strip()
            
            # Detect headings (# ## ### etc.)
            heading_match = re.match(r'^(#{1,6})\s+(.+)$', line)
            if heading_match:
                # Save previous section
                if current_section:
                    sections.append(current_section)
                
                level = len(heading_match.group(1))
                title = heading_match.group(2).strip()
                
                current_section = {
                    "id": f"section_{section_index}",
                    "title": title,
                    "text": "",
                    "index": section_index,
                    "level": level,
                    "section_type": self._classify_section_type(title),
                    "paragraphs": [],
                    "line_start": i
                }
                section_index += 1
            elif current_section and line:
                # Add content to current section
                current_section["text"] += line + "\n"
        
        # Add the last section
        if current_section:
            sections.append(current_section)
        
        # Refine section information
        for section in sections:
            section["text"] = section["text"].strip()
            section["paragraph_count"] = len(self._extract_paragraphs_from_text(section["text"]))
        
        return sections
    
    def _parse_markdown_paragraphs(self, markdown_content: str) -> List[Dict]:
        """Parse Markdown paragraphs."""
        paragraphs = []
        
        # Split paragraphs by double newlines
        raw_paragraphs = re.split(r'\n\s*\n', markdown_content)
        
        paragraph_index = 0
        current_section = "Unknown"
        
        for para_text in raw_paragraphs:
            para_text = para_text.strip()
            if not para_text:
                continue
            
            # Check if it's a heading
            if re.match(r'^#{1,6}\s+', para_text):
                # Update current section
                heading_match = re.match(r'^#{1,6}\s+(.+)$', para_text.split('\n')[0])
                if heading_match:
                    current_section = heading_match.group(1).strip()
                continue
            
            # Create paragraph object
            paragraph = {
                "id": f"para_{paragraph_index}",
                "text": para_text,
                "index": paragraph_index,
                "section": current_section,
                "word_count": len(para_text.split()),
                "char_count": len(para_text),
                "sentence_count": len(self._split_into_sentences(para_text)),
                "citation_count": 0,  # Will be calculated in subsequent steps
                "has_citations": False
            }
            
            paragraphs.append(paragraph)
            paragraph_index += 1
        
        return paragraphs
    
    def _extract_paragraphs_from_text(self, text: str) -> List[str]:
        """Extract paragraphs from text."""
        return [p.strip() for p in re.split(r'\n\s*\n', text) if p.strip()]
    
    def _split_into_sentences(self, text: str) -> List[str]:
        """Split text into sentences."""
        # Simple sentence splitting (can use more complex methods later)
        sentences = re.split(r'[.!?]+', text)
        return [s.strip() for s in sentences if s.strip()]
    
    def parse_sentences(self, pdf_path: str) -> List[str]:
        """
        Parse sentences, prioritizing MinerU's Markdown output.
        """
        if self.mineru_enabled and self.mineru_available:
            try:
                markdown_content, _ = self._extract_with_mineru(pdf_path)
                
                # Extract sentences from Markdown
                sentences = self._extract_sentences_from_markdown(markdown_content)
                
                logging.info(f"Extracted {len(sentences)} sentences from MinerU markdown")
                return sentences
                
            except Exception as e:
                logging.warning(f"MinerU sentence extraction failed: {e}")
                if not self.mineru_fallback:
                    raise
                logging.info("Falling back to traditional sentence extraction")
        
        # Fallback to traditional methods
        return super().parse_sentences(pdf_path)
    
    def _extract_sentences_from_markdown(self, markdown_content: str) -> List[str]:
        """
        Extract sentences from Markdown content.
        """
        # Clean Markdown markup
        clean_text = self._clean_markdown_text(markdown_content)
        
        # Separate main content and reference parts
        main_content, _ = self._separate_main_content_and_references(clean_text)
        
        # Use improved academic sentence splitting
        sentences = self._split_sentences_academic_aware(main_content)
        
        # Filter and clean sentences
        filtered_sentences = self._filter_invalid_sentences(sentences)
        cleaned_sentences = [self._clean_sentence_text(sent) for sent in filtered_sentences]
        
        return [sent for sent in cleaned_sentences if sent.strip()]
    
    def _clean_markdown_text(self, markdown_text: str) -> str:
        """
        Clean Markdown text, removing formatting but preserving content structure.
        """
        text = markdown_text
        
        # Remove code blocks
        text = re.sub(r'```.*?```', '', text, flags=re.DOTALL)
        text = re.sub(r'`[^`]+`', '', text)
        
        # Remove heading markers but keep text
        text = re.sub(r'^#{1,6}\s*', '', text, flags=re.MULTILINE)
        
        # Remove links but keep text
        text = re.sub(r'\[([^\]]+)\]\([^)]+\)', r'\1', text)
        
        # Remove bold and italic markers
        text = re.sub(r'\*\*([^*]+)\*\*', r'\1', text)
        text = re.sub(r'\*([^*]+)\*', r'\1', text)
        text = re.sub(r'__([^_]+)__', r'\1', text)
        text = re.sub(r'_([^_]+)_', r'\1', text)
        
        # Remove table markers
        text = re.sub(r'\|[^|\n]*\|', '', text)
        text = re.sub(r'^[-|: ]+$', '', text, flags=re.MULTILINE)
        
        # Clean up extra whitespace
        text = re.sub(r'\n\s*\n', '\n\n', text)
        text = re.sub(r'[ \t]+', ' ', text)
        
        return text.strip()
    
    def diagnose_pdf_quality(self, pdf_path: str) -> Dict:
        """
        Diagnose PDF quality, including MinerU processing capabilities.
        """
        diagnosis = super().diagnose_pdf_quality(pdf_path)
        
        # Add MinerU availability information
        diagnosis["mineru_available"] = self.mineru_available
        diagnosis["mineru_enabled"] = self.mineru_enabled
        
        if self.mineru_available:
            diagnosis["recommended_engine"] = "mineru"
            diagnosis["best_quality_score"] = 10.0
        
        return diagnosis

# Convenience function: Create an instance of the MinerU-integrated PDF processor
def create_mineru_pdf_processor(storage_root: str = "./data/papers/", 
                               mineru_enabled: bool = True) -> MinerUPDFProcessor:
    """
    Create an instance of the MinerU-integrated PDF processor.
    
    Args:
        storage_root: Storage root directory
        mineru_enabled: Whether to enable MinerU
        
    Returns:
        MinerUPDFProcessor instance
    """
    return MinerUPDFProcessor(storage_root=storage_root, mineru_enabled=mineru_enabled) 